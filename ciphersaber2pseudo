-- Produce an RC4 keystream of length n with
-- r rounds of key scheduling given key password
rc4(n, r, password):
    l ← length password
    -- Initialize the array.
    S ← zero-based array of 256 bytes
    for i in 0..255
        S[i] ← i
    -- Do key scheduling.
    j ← 0
    repeat r times
        for i in 0..255
            j ← (j + S[i] + password[i mod l]) mod 256
            S[i] ↔ S[j]
    -- Finally, produce the stream.
    keystream ← zero-based array of n bytes
    j ← 0
    for i in 0..n-1
        i' ← (i + 1) mod 256
        j ← (j + S[i']) mod 256
        S[i'] ↔ S[j]
        keystream[i] ← S[(S[i'] + S[j]) mod 256]
    return keystream

-- Ciphersaber-2 encrypt message m with key password and
-- r rounds of key scheduling
encrypt(m, r, password):
     n ← length m
     iv ← appropriately-chosen 10-byte IV
     password' ← prepend password to iv
     keystream ← rc4(n, r, password')
     ciphertext ← zero-based array of n + 10 bytes
     for i in 0..9
         ciphertext[i] ← iv[i]
     for i in 0..n
         ciphertext[i + 10] ← m[i] xor keystream[i]
     return ciphertext
CS2 decryption requires ciphertext and the encryption key used to produce the ciphertext.

-- Ciphersaber-2 decrypt ciphertext m with key password and
-- r rounds of key scheduling
decrypt(m, r, password):
     n ← length m
     iv ← m[0..9]
     delete the first 10 characters of m
     password' ← prepend password to iv
     keystream ← rc4(n - 10, r, password')
     plaintext ← zero-based array of n - 10 bytes
     for i in 0..n-10
         plaintext[i] ← m[i] xor keystream[i]
     return plaintext